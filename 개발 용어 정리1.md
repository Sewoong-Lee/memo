# 기술 면접 준비

##  프레임워크란?

> 프레임워크란, 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 일련의 협업화된 형태로 클래스들을 제공하는 것
>
> **프레임워크 vs 라이브러리**
>
> **라이브러리란** 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합
>
> **프레임워크**는 자동차의 프레임, 즉 기본적으로 구성하고 있는 뼈대
>
> 라이브러리는 자동차의 기능을 하는 부품을 이야기 하며, 프레임워크는 소형차 뼈대를 SUV로 바꾸지 못하듯 쉽게 변형이 불가

## **프레임워크의 장, 단점**

> **장점**
>
> **1) 효율적.**
>
> \- 아무것도 그려지지 않은 제로에서 코드를 일일이 짜는 것보다 시간과 비용이 훨씬 절약되며 생산성이 좋아집니다.
>
> **2) Quality 향상.**
>
> \- 버그 발생 가능성을 처리해줌으로써 개발자가 반복 작업에서 실수하기 쉬운 부분을 커버해줍니다. 다수의 개발자가 사용하며 수정하다 보니 이미 검증된 코드라고 볼 수 있습니다.
>
> **3) 유지 보수 Good!**
>
> \- 프레임워크를 쓰지 않고 일일이 코드를 짜 놓은 경우, 회사 입장에서 개발 담당자가 바뀌어버리면 곤란해집니다. 그러나 Framework를 사용하면 코드가 보다 체계적이어서 담당자가 바뀌더라도 위험부담을 줄일 수 있으며 유지 보수에 안정적입니다.
>
> 
>
> **단점**
>
> **1) 학습시간이 길다.**
>
> \- 코드를 본인이 짜 놓은 것이 아니기 때문에, 프레임워크에 있는 코드를 습득하고 이해하는 데 오랜 시간이 걸립니다.
>
> **2) 제작자의 의도된 제약 사항**
>
> \- 제작자가 설계한 구조를 어느 정도 유지한 채 코드에 살을 붙여나가야 합니다. 따라서 개발자는 자유롭고 유연하게 개발하는 데 한계가 있습니다.

## MVC 구조란?

> **Model, Viewm Controller 로 구성**
>
> 웹페이지를 구성하는 요소들(시각적, 데이터 담당) 끼리의 간섭 없이 각각 독립적으로 개발함으로서 큰 효율의 장정
>
> > **Model 이란?**
> >
> > 데이터를 처리하는 역할, Controller에서의 명령을 받고 DataBase 에서의 데이터를 저장, 삭제, 업데이트 등 변환의 작업을 수행한다
> >
> > **Model의 3가지 규칙**
> >
> > 1. 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야함
> > 2. View나 Controller에 대해서 어떤 정보도 알지 말아야 함 (Model은 오로지 데이터와 관련된 작업을 하기 때문에 화면의 UI에 간섭 할 수 없다.)
> > 3. 변경이 발생하면, 변경 통지에 대한 처리 방법을 구현해야 한다. 
>
> > **View란?**
> >
> > 시각적인 부분, 화면을 담당
> >
> > 화면의 뼈대인 html, 스타일링 하는 css, 이들을 동적으로 움직여주는 jsvascript가 해당함
> >
> > **Controller란?**
> >
> > 사용자가 접근하려는 URL에 따라서 요청을 파악한 후, 그 요청에 맞는 Model의 데이터를 의뢰하고 데이터를 View에 반영하여 사용자에게 알려준다.
> >
> > 전반적인 제어를 담당하는 역할
> >
> > View와 Model 사이에서 사용자의 요청을 분석하고 이에 맞는 데이터를 불러오는 중간 역할의 요소
> >
> > **MVC 구조의 작동 순서**
> >
> > 1. 사용자가 웹사이트에 접속
> > 2. Controller는 사용자가 요청한 웹페이지를 제공하기 위해서 Model에서 데이터를 호출
> > 3. Model은 데이터베이스나 파일과 같은 데이터 소스를 제어한 후 결과를 리턴
> > 4. Controller는 Model이 리턴한 결과를 View에 반영
> > 5. 데이터가 반영된 View는 사용자에게 보여짐



## DTO, DAO, VO?

> **DAO(Data Access Object)**
>
> DAO는 DB의 data에 접근하기 위한 객체로 직접 DB에 접근하여 데이터를 삽입, 삭제, 조회 등 조작할 수 있는 기능을 수행한다.
>
> MVC 패턴의 Model에서 이와 같은 일을 수행한다.
>
> 
>
> **DTO(Data Transfer Object)**
>
> DTO는 계층간(Controller, View, Business Layer) 데이터 교환을 위한 자바 빈즈(Java Beans)를 의미한다.
>
> DTO는 로직을 가지지 않는 데이터 객체이고 getter/setter메소드만 가진 클래스를 의미한다.
>
> **+) Java Beans**
>
> - Java로 작성된 소프트웨어 컴포넌트를 지칭하는 단어
> - 비즈니스 로직 부분을 담당하는 Java 프로그램 단위
> - (장점) JSP페이지가 복잡한 자바 코드로 구성되는 것을 피할 수 있음
> - (장점) 재사용 가능한 컴포넌트를 만들 수 있음
>
> 
>
> **VO(Value Object)**
>
> DTO와 달리 VO는 Read-Only속성을 값 오브젝트이다. 자바에서 단순히 값 타입을 표현하기 위해 불변 클래스(Read-Only)를 만들어 사용한다. 예를 들면 빨강은 Color.RED, 초록은 Color.GREEN 이렇게 단순히 값만 표현하기 위해 getter기능만 존재한다.
>
> **+) DTO vs VO**
>
> DTO는 가변의 성격을 가진 클래스이며 데이터 전송을 위해 존재한다.(getter/setter) 그에 반해 VO는 값 그 자체의 의미를 가진 불변 클래스(Read-Only)를 의미한다.(getter만 존재) DTO는 인스턴스 개념이라면 VO는 리터럴 개념.



## Restful 이란?

> **EST(Representational State Transfer)란?**

> REST는 WWW(월드 와이드 웹)와 같은 분산 하이퍼미디어 시스템을 위한 **소프트웨어 아키텍처**의 한 형식입니다.
>
> REST는 **올바른 HTTP 사용을 유도**하고 있기 때문에 HTTP 장점을 최대한 살린 서비스를 설계할 수 있습니다.
> REST의 기본 원칙을 성실하게 지킨 서비스를 "**RESTful** 하다"라고 표현합니다.
>
> 
>
> **REST 필수 규칙**
>
> URI는 정보의 자원을 표현해야한다.
> 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)으로 표현한다.
> 특정 행위의 표현은 JSON, XML 등을 이용한다.
>
> ```java
> POST http://localhost/bamdule/members
> {
>    "name" : "kim",
>    "email" : "xxxx@gmail.com"
> }
> 
> // member 저장
> ```
>
> 
>
> **HTTP Method 설명**
>
> | **Method** | **역할**      |
> | ---------- | ------------- |
> | **POST**   | Resource 생성 |
> | **GET**    | Resource 조회 |
> | **PUT**    | Resource 수정 |
> | **DELETE** | Resource 삭제 |
>
>  
>
> **Collection과 Document**
>
> **Document
> **1개의 개체를 나타내는 것으로 객체 인스턴스, DB의 Record와 유사한 개념을 가집니다. 
> 일반적으로 리소스의 집합 중 하나를 의미하며 Collection 뒤에 위치합니다.
>
> **Collection**
>
> Document들의 묶음입니다. 일반적으로 복수 형태의 단어를 사용합니다.
>
> **예제**
> http://localhost/members/{id}
> members가 Collections이고 {id}가 Document를 의미합니다.



## REST API 디자인 가이드

\-URI는 정보의 자원을 표현해야합니다.
\-자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)으로 표현합니다.
\-특정 행위의 표현은 JSON, XML 등을 이용합니다.
\-리소스 명은 동사보다 명사를 사용합니다.

> 1.**데이터 조회(GET)**
>
> ```java
> GET http://localhost/bamdule/members
> {
>   "name" : "kim",
>   "page" : 2,
>   "rows" : 20 
> }
> 
> url:'${path}/reply/list/'+bnum
>     
> @RequestMapping(value="/list/{bnum}", method = RequestMethod.GET)
> 	public List<Map<String,Object>> list(@PathVariable("bnum") int bnum, HttpSession session){
> 		String userid = (String)session.getAttribute("userid");		
> 		//댓글 조회
> 		List<Map<String,Object>> replist = replyService.selectList(bnum, userid);
> 		return replist;
> }
> ```
>
>  members 중에서 이름이 kim인 member들를 조회한다. (2페이지에 20개씩 조회)
>
> 
>
> 2.**데이터 삽입(POST)**
>
> ```java
> POST http://localhost/bamdule/members
> {
>   "name" : "kim",
>   "email" : "xxxx@gmail.com",
>   "birth" : "910505"
> }
> 
> url:'${path}/reply/
>     
> @RequestMapping(value="/", method=RequestMethod.POST)
> 	public String add(@RequestBody Reply reply,
> 			HttpSession session, HttpServletRequest request) {
> 		String userid = (String)session.getAttribute("userid");
> 		reply.setUserid(userid);
> 		reply.setIp(request.getRemoteAddr());
> 		replyService.insert(reply);
> 		return "ok";
> }
> ```
>
> member를 생성한다
>
>  
>
> 3. **데이터 수정(PUT)**
>
> ```java
> PUT http://localhost/bamdule/members/5
> {
>   "name" : "lee"
>   "email" : "xxxx@gmail.com",
>   "birth" : "971205"
> }
> 
> url:'${path}/members/'+num, //restful하게 설계
> 
> @RequestMapping(value="/{num}", method =  {RequestMethod.PUT,RequestMethod.PATCH} ,
> 	produces="application/text; charset=utf-8")
> public String modify(@RequestBody DTO dto){
> 	dtoService.update(dto);
> 	return "수정완료";
> }
> ```
>
> id가 5번인 member를 수정한다.
>
>  
>
> 4.**데이터 삭제 (DELETE)**
>
> ```java
> DELETE http://localhost/bamdule/members/5
> 
> url:'${path}/members/'+num
>     
> @RequestMapping(value="/{num}", method = RequestMethod.DELETE ,
> 				produces="application/text; charset=utf-8")
> 	public String delete(@PathVariable("num") int num){
> 		dtoService.delete(num);
> 		return "삭제완료";
> }
> ```
>
> id가 5번인 member를 삭제한다.



## 젠킨스

> 젠킨스는 지속적인 통합 및 배포를 위한 방법을 제공한다.
>
> 프로젝트의 빌드, 테스트 실행, 배포 등의 통합을 자동화한다.
>
> Maven, Ant, Gradle, Junit, Nexus와 잘 작동하며, Git, Svn과 같은 형상 관리 툴을 지원한다.
>
> 또한 Java 뿐만 아니라, WAS가 없는 Python, Node.js도 플러그인을 통해 젠킨스로 CI가 가능하다.
>
>  
>
> **젠킨스 사용의 장점**
>
> - 프로젝트의 표준 컴파일 환경에서 컴파일 오류 검출
> - 자동화 테스트 수행
> - 프로파일링을 통해 소스 변경에 따른 성능의 변화 감시
> - 테스트 환경에 대한 배포작업
> - 개발 업무를 도와주는 많은 플러그인을 가지고 있음
> - 각종 배치 작업의 간략화
> - Build 자동화의 확립
> - 코드 표준 준수여부 검사
> - 빌드 파이프라인 구성
>   - 2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용 된 프로젝트에는 그에 따른 빌드 파이프라인이 필요하다.
>   - 도메인 -> 서비스 -> UI 같이 각 레이어의 참조 관계에 따라 순차적으로 빌드를 진행하지 않으면 안된다.   젠킨스에서는 이러한 빌드 파이프라인 구성을 간단히 할 수 있고, 스크립트로 복잡한 제어도 가능하다.
>
>  
>
> #### **CI (Continous Integration) 란?**
>
> Build, Test를 실시하는 프로세스로 이러한 통합 프로세스를 계속 실시해 주는 것을 CI 라고 한다.
> 즉, 통합을 지속적으로 수행하는 것.
>
> #### **CD (Continous Delivery/Deploy) 란?**
>
> 프로젝트가 언제든지 신뢰가능한 수준으로 더 빠르게, 더 주기적으로 빌드하고 테스트를 함으로서 신뢰성을 보증하는 것이며, 이를 통해 변경사항 등에 대한 배포를 비용과 시간, 위험 등을 줄일 수 있다.
>
> ##### **CI 과정**
>
> ![다운로드](img/다운로드.png)
>
> 1. 개발자들은 형상 관리 툴을 사용해 코드를 공유한다.
> 2. Jenkins는 형상 관리 툴에서 코드를 가져와 오류를 체크한다.
> 3. 의존 관계에 있는 라이브러리들을 다운 받는다.
> 4. 테스트 코드가 있다면 테스트를 실행한다.
> 5. 테스트에 성공할 경우, 빌드를 해 실서버에 재배포 한다.
>
> ```
> Jenkins는 빌드, 테스트, 배포 등을 직접 실행하는 것이 아니다.
> ```
>
> 단지 빌드, 테스트, 배포를 `실행`시키는 역할을 할 뿐이다.
>
> ```
> work flow를 제어할 뿐, 소스를 가져오거나 Maven을 직접 실행하는게 아니다.
> ```



## OOP(Object Oriented Programming, 객체지향 프로그래밍)

> 모든 데이터를 현실에 빗대어 객체로 다루는 프로그래밍 기법.
>
> 
>
> #### **객체지향 언어의 5가지 특징**
>
> #### 1 ) 캡슐화 (Encapsulation) : 데이터와 함수를 하나로 묶는다.
>
> - 데이터의 세부 내용이 객체 은닉된다. 즉, 데이터 변경으로 인한 에러가 줄어들고, 객체들간에 데이터를 자세히 알 필요가 없으므로 코드가 단순해진다.
> - 객체와 함수의 재사용이 쉽다.
>
> #### 2 ) 정보은닉 (Information Hiding) : private으로 선언한 데이터는 자기 자신을 통해서만(setter, getter) 접근 가능하다.
>
> - 각 객체간의 수정이 다른 객체에 미치는 영향을 최소화 한다.
> - 외부 객체의 직접 접근을 막아 프로젝트 확장 시 오류를 최소화 한다.
>
> #### 3 ) 추상화 (Abstraction) : 불필요한 부분은 생략하고 중요한 것에만 초점을 맞춰 모델로 만든다.
>
> - 복잡한 모델을 중요한 것 만 추려 추상화 함으로써 시스템 구조를 시각적으로 표현할 수 있다.
> - 완전한 시스템이 구축되지 않더라도 개략적으로 모델을 만들어 테스트 하고 살을 붙여나갈 수 있다.
>
> #### 4 ) 상속성 (Inheritance) : 부모클래스에 정의된 모든 것을 자식 클래스가 물려받는다.
>
> - 재정의 할 필요가 없어 코드 작성이 간결해진다.
> - 상속으로 인한 최소한의 규칙을 통해 프로젝트의 확장 시 오류를 최소화 한다.
> - 자식클래스에서 새로운 함수를 추가하거나 **부모 클래스의 함수를 재정의(Overriding)**해 사용할 수 있다.
> - 클래스의 재사용이 쉽다.
>
> #### 5 ) 다형성 (Polymorphism) : 호출하는 객체에 따라 다른 동작을 한다.
>
> - **하나의 클래스에서 같은 이름의 함수를 여러 개 가질 수 있다(Overloading)**. 호출하는 객체가 어떤 인풋 파라미터를 사용해 호출하냐에 따라 각자 다른 함수가 호출되게 한다. 즉, 비슷한 기능을 하는 다른 함수를 만들 때 불필요하게 너무 많은 함수명을 만들어 내 가독성이 떨어지는 문제를 해결할 수 있다.



## **객체지향 설계의 5가지 원칙 (S.O.L.I.D)**

> **객체지향 디자인이 이루고자 하는 목적은 작동하기만 하는 소프트웨어가 아닌 관리가능한, 재사용가능한, 신뢰할 수 있는, 유연한 소프트웨어의 개발**

> 1) #### **단일 책임 원칙(Single responsibility principle)**
>
> **모든 메서드 또는 클래스는 단 하나의 책임을 가져야한다는 의미**입니다. 요즘 한창 각광받고 있는 MSA에서는 한층 더나가 서비스에 1개의 책임을 가지게 하고 있기도 합니다.
>
> **EX)**
>
> ```
> public class BookService() {
> 
>     public void findBookById(String query) {
>         // DB에서 찾아오기..
>         // Log 파일에 찾은 정보 쓰기..
>     }
> 
> }
> ```
>
> 위의 클래스에서 메서드는 DB에서 책을 찾아오고 찾아온 정보를 Log파일에 기록하는 2가지의 일을 가지고 있습니다. 
>
> 단일 책임 원칙은 Method, Class 등에 적용될 수 있으며 Class는 이러한 단일책임원칙을 지키지 못한다고 할 수 있습니다. 
>
> 이런 method는 각자 일에 맞춰서 나누어 method를 분할하고 사용하는 곳에서 조합하여 사용해야합니다. 단일 책임 원칙에 맞게 수정하면 아래와 같습니다.
>
> ```
> public class BookService() {
> 
>     public String findBookById(String query) {
>         // DB에서 찾아오기..
>     }
> 
>     public void WriteLog(String log) {
>         // Log 파일에 찾은 정보 쓰기..
>     }
> }
> ```
>
> 2. #### **개방/폐쇄의 원칙(Open/closed principle)**
>
> **소프트웨어의 entity(클래스, 모듈, 메서드)들의 확장은 권장하지만 기존 모듈의 수정은 권장하지 않는다는 의미**입니다. 즉 확장은 할 수 있지만 수정은 최소화 하도록 프로그램을 작성해야합니다. OCP원칙은 일반적으로 의존성을 추상화 하는 방법으로 달성할 수 있습니다. `구현된 class`를 사용하기 보다는 `interface`, `abstract class`을 사용하는 것입니다.
>
>  **EX)**
>
> 아래 class를 보겠습니다. 아래 Method는 영수증을 모아서 현금으로 계산을 하는 class입니다. 정상적으로 기능하는 Method입니다.
>
> ```
> void checkOut(Receipt receipt) {
>   // 영수증의 금액 취합
>   Money total = Money.zero;
>   for (item : items) {
>     total += item.getPrice();
>     receipt.addItem(item);
>   }
>   // 현금으로 계산
>   Payment p = acceptCash(total);
>   receipt.addPayment(p);
> }
> ```
>
> 정상적으로 운영하는 도중 신용카드로도 결재할 수 있게해달라는 요건이 추가되었습니다. 우리는 이때 어떻게 이 요건을 달성할 수 있을까요? 가장쉽게 떠오르는 방법이 if를 이용하는 것입니다. 그렇다면 아래와 같이 method를 수정해야합니다.
>
> ```
> void checkOut(Receipt receipt, boolean isCash) {
>   // 영수증의 금액 취합
>   Money total = Money.zero;
>   for (item : items) {
>     total += item.getPrice();
>     receipt.addItem(item);
>   }
> 
>   Payment p = null;
>   if(isCach) p = acceptCash(total);   // 현금으로 계산
>   else p = acceptCreditCard(total);   // 신용카드로 계산
> 
>   receipt.addPayment(p);
> }
> ```
>
> 이러한 방식은 제가 지금 설명하고 있는 OCP 원칙을 지키지 못하는 것입니다. 왜냐하면 checkOut이라는 기존메서드를 수정해버렸기 때문입니다. **OCP 원칙을 지키는 방식으로 수정**해보겠습니다.
>
> ```
> interface PaymentMethod {
>     Payment acceptPayment(Money total);
> }
> 
> class PaymentCash {
>     public Payment acceptPayment(Money total){
>         // 현금 계산 구현
>     }
> }
> 
> class PaymentCreditCard {
>     public Payment acceptPayment(Money total){
>         // 신용카드 계산 구현
>     }
> }
> 
> void checkOut(Receipt receipt, PaymentMethod method) {
>   // 영수증의 금액 취합
>   Money total = Money.zero;
>   for (item : items) {
>     total += item.getPrice();
>     receipt.addItem(item);
>   }
> 
>   // function을 호출할 때 함께 들어오는 PaymentMethod Type으로 어떻게 계산할지가 정해진다.
>   Payment p = method.acceptPayment(total);
>   receipt.addPayment(p);
> }
> ```
>
> 위와 같이 구현 후 checkOut을 client가 호출할 때 PaymentMethod의 구현타입인 PaymentCash, PaymentCreditCard 중 하나와 함께 호출한다면 **앞으로 비트코인으로 결제하는 방법이 추가된다고 하더라도 checkOut method의 수정없이 PaymentMethod의 구현체를 1개더 생성하여 확장하는 것으로 목표를 달성**할 수 있습니다.
>
>  
>
> 3. #### **리스코브 치환 원칙(Liskov Substitution Principle)**
>
> **A is B라는 상속 관계가 있을때, B는 sub class이고 A는 base class입니다. 이때 B의 행위는 A의 행위의 예상할 수 있는 범위내에서 이루어져야 한다는 것**입니다.
>
>  **EX)**
>
> ```
> class Rectangle {
>     private int width;
>     private int height;
> 
>     public void setHeight(int height) {
>         this.height = height;
>     }
> 
>     public int getHeight() {
>         return this.height;
>     }
> 
>     public void setWidth(int width) {
>         this.width = width;
>     }
> 
>     public int getWidth() {
>         return this.width;
>     }
> 
>     public int area() {
>         return this.width * this.height;
>     }
> }
> class Square extends Rectangle {
>     @Override
>     public void setHeight(int value) {
>         this.width = value;
>         this.height = value;
>     }
> 
>     @Override
>     public void setWidth(int value) {
>         this.width = value;
>         this.height = value;
>     }
> }
> ```
>
> 위예제를 봅시다. 위의 예제는 정사각형(Square)가 사각형(Rectangle)을 상속 받아서 구현을 하고 있습니다. 훌륭하게 재사용을 하고 있는것 처럼보일 수 있습니다. 하지만 그렇지 않습니다. 아래에서 Client가 사용한다고 해보겠습니다.
>
> ```
>  @Test
>     public void squreTest() {
>         // given
>         Rectangle square = new Sqaure();
>         square.setWidth(4);
>         square.setHeight(5);
>         // when
>         int area = square.area();
>         // then
>         assertThat(area, is(20)); // is True? not!!
>     }
> ```
>
> 결과는 무심하게도 실패입니다. 실패하는 이유는 Rectangle에 대한 요소가 Sqaure의 예상범위 밖에 있기 때문입니다. 이렇듯 위의 `정사각형은 사각형이다` 예제는 LSP를 만족하지 못한다고 할 수 있습니다. `정사각형은 사각형이다`의 해결 방법은 상속을 해제하던지 정상적인 동작을 하지 못하는 area를 아래로 Square Class로 가져와 재정의 해야할 것입니다.
>
> LSP는 왜 지켜야 할까요? LSP는 위와 같은 상황이 일어나지 않도록 하는 **상속의 룰 로써 최고의 상속 구조 특성**을 갖추게 하며, OCP를 위반하지 않도록 인도하는 원칙 이라고 말하고 있습니다.
>
>  
>
> 4. #### **인터페이스 분리의 원칙(Interface Segregation Principle)**
>
> 범용적인 인터페이스 보다는 Client가 실제로 사용하는 Interface를 만들어야 한다는 의미로 **인터페이스를 사용에 맞게 끔 분리해야한다는 설계원칙**입니다.
>
> ISP원칙을 지킴으로써 좋은것은 어떤것일까요? 만약 **Interface를 지나치게 범용적으로 구현한다면 그 Interface를 상속받은 Class는 자신이 사용하지 않는 Interface마저 억지로 구현**해야합니다. 그리고 사용하지 않는 Interface의 method가 변경되게 되더라도 기존의 class를 변경해야합니다. 이것은 **OCP원칙을 위배**하기도 합니다.
>
>  **EX)**
>
> 복합기가 있습니다. 그리고 복합기는 복사, 프린터, 팩스의 기능이 가능합니다. 그렇다면 아래와같이 Inteface를 구성할 수 있습니다.
>
> ```
> public interface multifunction {
>     void copy();
>     void fax();
>     void print();
> }
> ```
>
> 이렇게 구성한다고 합시다. interface를 보게되면 복합기가 copy, fax, print를 할 수 있다는 것을 알 수 있습니다. 하지만 사실 복합기는 복사기, 팩스기, 프린터기가 합쳐진 것입니다. 위의 interface로 복사기도 구현할 수 있고 팩스도 구현할 수 있고 프린터도 구현할 수 있습니다. 복사기를 구현해보겠습니다.
>
> ```
> public class copyMachine implements multifunction {
> 
>     @Override
>     public void copy() {
>         System.out.println("###복사###")
>     }
> 
>     @Override
>     public void fax() {
> 
>     }
> 
>     @Override
>     public void print() {
> 
>     }
> }
> ```
>
> copy를 하면 정상적으로 동작합니다. 그런데 fax와 print를 보면 그냥 무의마한 method로 남습니다. 만약 interface가 아래와 같이 변경되면 어떻게 될까요?
>
> ```
> public interface multifunction {
>     void copy();
>     void fax(Address from, Address to);
>     void print();
> }
> ```
>
> `copyMachine` class는 fax를 사용하지 않지만 class를 수정해야만 합니다. 이는 OCP원칙을 위반합니다.
>
> 이를 방지하기 위해서는 위의 interface는 아래와 같이 변경해야합니다.
>
> ```
> public interface Print {
>     void print();
> }
> 
> public interface Copy {
>     void copy();
> }
> 
> public interface Fax {
>     void fax();
> }
> 
> public interface multifunction extends Print, Copy, Fax{
> }
> ```
>
> 이렇게 하면 각자의 기능에 맞게 사용할 수 있게 됩니다. 이게 바로 ISP입니다.
>
>  
>
> 5. #### **의존성 역전의 원칙(Dependency Inversion Principle)**
>
> **어떤 Class를 참조해야하는 상황**이 생긴다면 그 Class를 직접 참조하는 것이 아니라 그 대상을 **추상 클래스로 만들어서 사용**하라는 원칙입니다. 단, **해당 추상 클래스는 참조 하는 클래스(상위 모듈)의 목적을 기본으로 합니다.**
>
> 일반적으로 절차지향적으로 생각할 때 상위모듈이 하위모듈에 의존 적일 수 밖에 없습니다. 왜냐하면 **상위 모듈은 하위 모듈의 결과에 따라 좌우되기 때문**입니다. 하지만 이러한 방법은 객체지향에서는 정상적인 상태가 아닙니다. 왜냐하면 하위모듈의 변경에 의해서 상위모듈을 연쇄적으로 변경해야하기 때문입니다. **객체 지향에서는 상위모듈을 하위모듈에 독립화를 시킴으로써 이와같은 문제를 해결**합니다.
>
> **EX)**
>
> String을 복사하는 Class를 만들어 보겠습니다.
>
> ```
> public interface Reader {
>     String getString();
> }
> 
> public interface Writer {
>     String putString(String str);
> }
> 
> public class StringCopier {
>     void copy(Reader reader, Writer writer) {
>         writer.putString(reader.getString());
>     }
> }
> ```
>
> 이렇게 구현했다고 해봅시다. 위의 `StringCopier` class는 Reader와 Writer를 의존하고 있습니다. 따라서 현재 상태에서의 상위모듈은 StringCopier이며 하위모듈은 Reader와 Writer입니다. **이렇게 추상화된 객체에 의존**하고 있습니다. 이렇게 설계했을때의 이점은 Reader와 Writer의 설계에 맞으면 어떠한 구현도 들어올 수 있다는 것입니다. 만약 Reader를 키보드입력으로, Writer를 시스템 출력이라고 한다면 거기에 맞게 아래와 같이 구현하여 의존성을 주입하면 그만입니다.
>
> ```
> public Keyboard implements Reader {...}
> public SystemWriter implements Writer {...}
> ```
>
> 만약 Keyboard입력이 아닌 File에서 입력을 받는다 하여도 Reader를 새로 implements하고 Client에서 주입되는 Instance만 변경하면 그만입니다. **StringCopier class는 변경되지 않습니다.**



## AOP(Aspect Oriented Programming, 관점지향 프로그래밍)

> **OOP를 더욱 발전시키기 위한 개념**이다. 
>
> 하나의 소프트웨어가 하나의 거대한 OOP로써 설계, 프로그래밍 되었다면 이것을 각 기능별로 모듈화 해서 분리를 시키는 개념이다.
>
> 
>
> ![img](img.gif)
>
> 기존의 단순 OOP에서는 계좌이체, 입출금, 이자계산의 서비스가 각각의 OOP로 프로그래밍 되었고, 각각의 OOP 모두 기능 작동을 위해 로깅, 보안, 트랜잭션을 하는 코드가 구현되어있었다.
>
> 그런데 계좌이체, 입출금, 이자계산 비즈니스 모두가 공통적으로 갖는 로직이 있는 것을 알 수 있다. 그렇다면 이것을 각각의 OOP 소스코드에서 제거하고 외부로 빼내 하나의 공통 모듈로 만들 수 있다. 이것이 바로 기존의 OOP에 AOP 관점을 더해 발전시킨 기법이다.
>
> **Core Concern(핵심 관심) :** 각 서비스의 핵심 비즈니스 로직.  i.e. 계좌이체, 입출금, 이자계산
> **Crosscut Concern(횡단 관심) :** 공통 모듈.  i.e. 로깅, 보안, 트랜잭션
>
> **AOP의 핵심은 공통 모듈을 분리시켜 해당 소스코드가 외부의 다른 클래스에서 존재하는 것**이다.
>
> AOP개념을 도입함으로써 얻는 장점
>
> - 각 비즈니스 로직마다 복붙을 통해 생겨난 중복 코드가 사라진다.
> - 각 비즈니스 로직을 구현하는 개발자는 자기 자신의 비즈니스 코드에만 집중할 수 있어 코드가 간결해지고, 유지보수가 쉬워진다.
> - 재활용성이 더욱 높아진다.
>
> **AOP의 구성 요소**
>
> - **JointPoint :** Crosscut Concern(횡단 관심)을 삽입할 **시점(when)**.
>   i.e. 함수가 Before(실행 전), After(실행 후), AfterReturning(반환 후), AfterThrowing(예외 발생시), Around(실행 전과 후)
> - **PointCut :** 어떤 클래스의 어떤 함수에 삽입할건지. 삽입할 **위치(where)**.
> - **Aspect :** **JointPoint(when) + PointCut(where)**
> - **Advice :** **무엇(what)**을 삽입할건지.
> - **Weaving :** **Aspect(when + where) + Advice(what)**. 위빙을 통해 지정된 객체를 **새 Proxy 객체로 생성**한다.
> - **Proxy :** **Crosscut Concern(횡단 관심)**이 Core Concern(핵심 관심)에서 직접 실행되지 않고 **Proxy(대리인)을 생성해 실행**된다.



## 메모리 영역

> ![다운로드 (1)](img/다운로드 (1).png)

> **1) Code(Text)**
>
> - 우리가 작성한 **소스코드**가 들어 가는 부분. 즉, 실행할 프로그램의 코드가 저장되는 영역으로 **텍스트(code)영역** 이라고도 부른다.
> - 코드영역은 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 **함수, 제어문, 상수** 등이 여기에 지정된다.
> - 컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 **Read-Only** 로 지정돼있다.
>
> **2) Data**
>
> - 프로그램의 **전역 변수와 정적(static) 변수가 저장되는 영역**이다.즉, 프로그램이 구동되는 동안 항상 접근 가능한 변수가 저장되는 영역이다.
> - 전역변수, static 값을 참조한 코드는 컴파일 하고 나면 Data 영역의 주소값을 가르키도록 바뀐다.
> - 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
> - 실행 중도에 전역변수가 변경 될 수도 있으니 이 영역은 **Read-Write**로 지정돼있다.
>
> (상위 그림에서는 표현되어있지 않지만,) 초기화 된 데이터는 Data 영역에 저장되고,초기화 되지 않은 데이터는 BSS(Block Stated Symbol)영역에 저장된다.
>
> 
>
> **3) Stack**
>
> - 함수의 호출과 관계되는 **지역 변수와 매개변수가 저장되는 영역**이다.
> - Stack은 함수의 호출과 함께 할당되며, **함수의 호출이 완료되면 소멸**한다.
> - 원시타입의 데이터가 값과 함께 할당된다.
> - Heap 영역에 생성된 Object 타입의 데이터 참조값이 할당된다.
> - 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
> - **컴파일 타임에 크기가 결정되기 때문에 무한히 할당 할 수 없다.** 재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 **stack overflow 에러**가 발생한다.
>
> **4) Heap**
>
> - **런타임에 크기가 결정되는 메모리 영역**이다.
> - 사용자에 의해 메모리 **공간이 동적으로 할당되고 해제**된다.
> - 참조형의 데이터의 값이 저장된다.
> - 예를 들어 클래스, 클로저가 이 부분에 해당 된다.
> - Heap은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
> - HEAP과 STACK영역은 사실 같은 공간을 공유한다. HEAP이 메모리 위쪽 주소부터 할당되면 STACK은 아래쪽부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 HEAP OVERFLOW, STACK OVERFLOW라고 칭합니다.
> - 힙 영역은 쉽게 말해서 '사용자에 의해 관리되는 영역'입니다. 흔히 동적으로 할당 할 변수들이 여기에 저장된다고 보시면 됩니다. 또한 Java나 C++에서 new 연산자로 생성하는 경우 또는 class, 참조 변수들도 Heap영역에 차지하게 됩니다.
>
> **면접 예상 질문**
>
>
> **Q.프로세스의 구역을 나눈 이유가 무엇인가?**
>
> 최대한 데이터를 공유하여 메모리 사용량을 줄이기 위함입니다.
>
> Code는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유합니다.
>
> 예를들면 같은 프로그램을 여러개 띄울때 Code영역을 공유할 수 있습니다.
>
> Stack과 데이터를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위함 입니다.
>
> 
>
> **Q.data영역과 bss 영역을 구분하는 이유는 무엇인가?**
>
> 초기화되지 않은 변수는 프로그램이 실행될 때 영역만 잡아주면 되고 그 값을 프로그램에 저장하고 있을 필요는 없으나 초기화가 되는 변수는 그 값도 프로그램에 저장하고 있어야 하기 때문이다. 따라서 bss 영역 변수들이 많아져도 프로그램의 실행코드 사이즈를 늘리지 않는다.



## CPU 스케줄링

> 메모리에 올라온 프로세스들 중 어떤 프로세스를 먼저 처리할지 순서를 정하는 것. 즉, Ready Queue에 있는 프로세스들 중에 누구에게 CPU를 할당해 줄 것인지 정한다.
>
> #### 왜 필요할까?
>
> > CPU는 한번에 하나의 프로세스만 실행시킬 수 있다. 따라서 특정 프로세스가 I/O 요청에 의해 대기해야할 경우 CPU는 그저 놀고 있게 된다.
> >
> > 다중 프로그래밍에서는 이러한 시간을 생산적으로 활용하고자 CPU를 그 프로세스로부터 회수해 다른 프로세스에 할당한다.
> >
> > 그 외 여러가지 예시들도 있겠지만 CPU 스케줄링이 필요한 이유는 하나로 통일되는데, 바로 CPU 이용률 극대화 이다.
>
> 
>
> #### 선점 및 비선점 스케줄링
>
> CPU 스케줄러는 다음 네 가지 상황에서 동작한다.
>
> - 한 프로세스가 실행상태에서 대기 상태로 전환될 때
>   ex) I/O 요청에 의한 대기
>
>   
>
> - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
>   ex) 할당된 시간이 다 끝났을 때 (타이머 인터럽트가 발생했을 때)
>
>   
>
> - 프로세스가 대기 상태에서 준비완료 상태로 전환될 때
>   ex) I/O 종료 시
>
>   
>
> - 프로세스가 종료될 때
>
> #### 비선점 (nonpreemptive)
>
> 1, 4번 상황과 같이 프로세스가 자발적으로 CPU를 반납하는 경우, 우리는 이러한 스케줄링 방법을 `비선점` 이라고 한다.
>
> 비선점 스케줄링하에서는, 일단 CPU가 한 프로세스에게 할당되면 프로세스가 종료되든지, 또는 대기 상태로 전환해 CPU를 방출할 때 까지 점유한다.
>
> #### 선점 (preemptive)
>
> 2, 3번 상황과 같이 강제적으로 CPU를 빼앗기는 경우, 우리는 이러한 스케줄링 방법을 `선점` 이라고 한다.
>
> Windows, macOS, Linux를 포함한 거의 모든 최신 운영체제들은 선점 스케줄링 알고리즘을 사용한다.
>
> #### 스케줄링 기준
>
> 서로 다른 CPU 스케줄링 알고리즘들은 다른 특성이 있으며 특정 상황에서 어떠한 알고리즘을 선택하려면, 우리는 다양한 알고리즘들의 서로 다른 특성을 반드시 고려해야 한다.
>
> CPU 스케줄링 알고리즘들을 비교하기 위한 기준은 다음과 같다.
>
> #### CPU 이용률 (utilization)
>
> 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율을 말한다.
>
> CPU 이용률이 높을 수록 CPU가 바쁘게 일을 하고 있다는 것을 뜻한다.
>
> #### 처리량 (throughput)
>
> 단위 시간당 완료된 프로세스의 개수로,
> 긴 프로세스인 경우 이 비율을 몇 초 동안 한 프로세스가 될 수도 있고, 짧은 프로세스인 경우 처리량은 초당 수십 개의 프로세스가 될 수도 있다.
>
> #### 총처리 시간 (turnaround time)
>
> 프로세스가 시작해서 끝날 때까지 걸리는 시간으로,
> 준비큐에서 대기한 시간, CPU에서 실행하는 시간, I/O 시간을 합한 시간이다.
>
> #### 대기 시간 (waiting time)
>
> 프로세스가 준비 큐에서 대기하면서 보낸 시간의 합이다.
>
> #### 응답 시간 (response time)

![image](img/image-16304261642911.png)

> 하나의 요구를 제출한 후 첫 번째 응답이 나올 때까지의 시간이다. 이 기준은 응답이 시작되는 데까지 걸리는 시간이지, 그 응답을 출력하는 데 걸리는 시간은 포함하지 않는다.
>
> #### 어떤게 좋을까
>
> CPU 이용률과 처리량을 최대화하고 총처리 시간, 대기 시간, 응답 시간을 최소화 하는 것이 바람직하다.
>
> 
>
> ## 스케줄링 알고리즘
>
> #### 선입 선처리 (FCFS)
>
> 가장 간단한 CPU 스케줄링 알고리즘으로, CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다. (비선점)
>
> 모든 다른프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 `convoy effect (호위 효과)` 라고 하는데, `선입 선처리` 방식에서는 `convoy effect`가 발생하여 CPU와 장치 이용률이 저하되는 결과를 낳을 수 있다.
>
> #### SJF (Shortest Job First)
>
> 가장 작은 CPU 버스트 시간을 가진 프로세스에게 우선적으로 CPU를 할당한다. 버스트 시간이 동일하다면 `FCFS` 방식으로 동작한다.
>
> ![image (1)](img/image (1).png)
>
> `SJF` 스케줄링 알고리즘은 주어진 프로세스 집합에 대해 최소의 평균대기 시간을 가진다는 점에서 최적의 알고리즘임을 증명할 수 있다.
>
> 하지만 컴퓨터 입장에서는 프로세스가 얼만큼의 CPU 버스트 길이를 가지는지 미리 알 수가 없다.
> 왜냐하면, I/O를 요청하는 명령어가 언제 나올 지 모르기 때문이다. 따라서 `SJF` 스케줄링 알고리즘은 사실상 구현이 불가능 하다.
>
> 추가적으로,
> 위 사진에서는 `SJF`가 비선점으로 작동하지만, 선점으로도 작동할 수 있는데, 이 경우에는 현재 실행되고 있는 프로세스의 남은 시간보다도 더 짧은 CPU 버스트를 가진 프로세스가 CPU를 선점할 수 있다.
>
> #### RR (Round Robin)
>
> `라운드 로빈` 스케줄링 알고리즘은 `FCFS`과 유사하지만 `시간 할당량(time quantum)`을 정의하여 선점형으로 동작한다.
>
> 동작 방식은 다음과 같다.
>
> - 프로세스의 CPU 버스트가 `시간 할당량` 보다 작으면 프로세스는 CPU를 자발적으로 방출한다.
> - 프로세스의 CPU 버스트가 `시간 할당량` 보다 크면 타이머가 끝나고 운영체제에 인터럽트를 발생할 것이다. `문맥교환`이 일어나고 준비 큐의 다음 프로세스가 CPU를 사용한다.
>
> `라운드 로빈` 알고리즘의 성능은 시간 할당량의 크기에 매우 많은 영향을 받는다.
>
> - 시간 할당량이 매우 작다면 `문맥교환` 하는 데 시간을 다 쓰게 된다.
> - 시간 할당량이 매우 크다면 `FCFS`와 똑같이 동작하게 된다.
>
> #### 우선순위 스케줄링 (Priority Scheduling)
>
> 운영체제 혹은 사용자에 의해 프로세스에 우선순위를 부여하고, CPU는 가장 높은 우선순위를 가진 프로세스에 할당된다.
>
> `우선순위 스케줄링`은 선점형이거나 또는 비선점형이 될 수 있다.
>
> - 선점형은 새로 도착한 프로세스의 우선순위가 현재 실행되는 프로세스의 우선순위보다 높으면 CPU를 선점한다.
> - 비선점형은 단순히 준비완료 큐의 머리부분에 새로운 프로세스를 넣는다.
>
> `우선순위 스케줄링`의 주요 문제는 `무한 봉쇄(indefinite blocking)` 또는 `기아 상태(startvation)` 이다.
> 높은 우선순위의 프로세스가 계속 들어올 경우, 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우가 발생할 수 있다.
>
> `starvation` 문제에 대한 한 가지 해결 방안은 `노화(aging)` 이다.
> 오랫동안 시스템에서 대기한는 프로세스들의 우선순위를 점진적으로 증가시키는 방법이다.
>
> #### 다단계 큐 (Multilevel Queue) 스케줄링
>
> 여러개의 준비 큐를 가지는 스케줄링 방법이다. 각 큐는 자기만의 스케줄링 알고리즘을 가질 수 있고, 큐와 큐 사이의 스케줄링도 존재한다.
>
>  ![image (2)](img/image (2).png)
>
> 각 큐는 절대적인 우선순위를 가진다. 우선순위가 높은 큐에 존재하는 프로세스부터 실행되며 우선순위가 높은 큐가 비어있어야 그 아래 단계의 큐를 실행할 수 있다.
>
> 프로세스가 생성될 때 정해지는 우선순위에 따라서 해당 우선순위에 해당하는 준비 큐에 등록된다.
>
> 작업은 한 큐에서 다른 큐로 옮겨지지 않기 때문에 스케줄링 부담이 적지만 융통성이 떨어진다.
>
> 큐 간의 절대적인 우선순위 때문에 `startvation`이 발생할 수도 있다. 이 경우에 큐들 사이에 시간을 나누어 사용할 수도 있다.
>
> #### 다단계 피드백 큐(Multilevel Feedback Queue) 스케줄링
>
> `다단계 피드백 큐` 스케줄링 알고리즘 에서는 프로세스가 큐들 사이를 이동하는 것을 허용한다.
>
>  ![image (3)](img/image (3).png)
>
> 큐 사이를 이동하는 아이디어는 다음과 같다.
>
> - 프로세스들을 CPU 버스트 성격에 따라 구분한다.
> - 어떤 프로세스가 CPU 시간을 너무 많이 사용하면, 낮은 우선순위의 큐로 이동된다.
> - I/O 중심의 프로세스와 대화형 프로세스들을 높은 우선순위의 큐에 넣는다. (이들은 통상적으로 짧은 CPU 버스트가 특징이다.)
> - 마찬가지로 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위 큐로 이동할 수 있다. 이 방법으로 `startvation` 을 예방한다.



## 스레드

> #### 프로세스(process)란?
>
> 프로세스(process)란 단순히 실행 중인 프로그램(program)이라고 할 수 있습니다.
>
> 즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말합니다.
>
> 이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성됩니다.
>
> **간단하게** OS에서 하나의 실행중인 프로그램이라고 할 수 있습니다. 프로세스는 리소스와 쓰레드로 구성되며, 모든 프로세스는 하나 이상의 쓰레드를 가지고 있습니다.![82154484-4273c600-98a9-11ea-84b0-d643b47ed54a](img/82154484-4273c600-98a9-11ea-84b0-d643b47ed54a.png)
>
> #### 스레드(thread)란?
>
> 스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다.
>
> 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행합니다.
>
> 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 합니다.
>
> **경량화된 프로세스라고 생각하시면 됩니다.** 실제로 프로세스 내에서 실제 작업을 수행합니다.
> 쓰레드는 하나의 프로세스에서 여러 개가 존재할 수 있는데, 이들을 서로 **Code, Data, Heap** 영역을 공유합니다.![82154517-7c44cc80-98a9-11ea-9848-63a04a8a8b66 (1)](img/82154517-7c44cc80-98a9-11ea-9848-63a04a8a8b66 (1).png)
>
> ####  단일 쓰레드
>
> **안드로이드**에서도 앱을 실행하면 해당 앱의 프로세스가 생성되며, 쓰레드가 하나 할당됩니다. 바로 이 쓰레드가 **메인 UI 쓰레드**입니다.
>
> 그렇다면 여기서 외부 파일을 다운로드 받아야할 경우를 생각해봅시다. 현재 프로세스에는 UI 쓰레드 하나밖에 없기 때문에 외부 파일 다운로드가 시작되는 순간, 앱은 멈추게 됩니다. 즉 다운로드가 완료될 때 까지, 사용자의 상호작용에 반응을 못합니다. 그럼 이렇게 무거운 작업이 있을 경우마다 메인 UI 쓰레드의 작업을 기다려줘야 할까요?
>
> ![82157753-570e8900-98be-11ea-9c67-269d6c87d7c1](img/82157753-570e8900-98be-11ea-9c67-269d6c87d7c1.png)
>
>  프로세스는 여러개의 쓰레드를 가질 수 있습니다. 별도의 쓰레드를 생성한 후, 이 쓰레드로 하여금 외부 파일을 다운로드를 하도록 하면 UI 쓰레드와 별개로 동작합니다. 이것을 **멀티 쓰레딩**이라고 합니다.
> 따라서 UI 쓰레드를 통해 상호작용은 가능하면서 다운로드와 같은 작업은 계속 진행되게 됩니다.
>
> 여기서 주의해야할 점은, UI 쓰레드를 제외한 쓰레드는 UI와 상호작용을 할 수 없다는 것입니다. 이 점을 유의하여 핸들러를 통해 메인쓰레드로 해당 코드를 동작시켜야 합니다.
>
> 멀티 쓰레드는 보통 비동기식으로 멀티 쓰레드를 많이 사용합니다.
>
>  
>
> #### 멀티 프로세스?
>
> **멀티 프로세스**는 여러개의 프로세스를 이용하여 작업을 병렬적으로 처리하는 것을 의미합니다.
> 이러한 멀티 프로세스를 안쓰고 멀티 쓰레드를 사용하는 이유는 뭘까요?
>
>  ![82157913-4f031900-98bf-11ea-845f-811d4d0d1416](img/82157913-4f031900-98bf-11ea-845f-811d4d0d1416.png)
>
> - **자원의 효율성**: 멀티 프로세스로 작업을 수행하면 낭비되는 자원이 많게 됩니다. 멀티 쓰레드를 사용하면 프로세스를 생성하는 자원과 프로세스가 할당되어있는 자원을 절약할 수 있습니다.
> - **메모리 공유**: 프로세스간의 통신보다 쓰레드 간의 통신의 비용이 훨씬 적습니다. 왜냐하면 스레드끼리는 대부분의 자원들을 공유하기 때문에 처리 비용이 줄어든다는 이점과, 전환 속도가 빠르다는 이점이 있습니다.
>
>  
>
> #### 코어
>
>  만약 쓰레드를 여러개 생성하였다면 하나의 프로세스에서는 어떻게 동작할까요? 그 배경에서는 **코어**라는 개념이 있습니다.
>
> 코어는 CPU에서 연산을 담당하는 핵심장치입니다. 흔히 우리가 4코어 8쓰레드, 8코어 16쓰레드 라는 말을 많이 들어보셨을겁니다. 그것은 하나의 CPU에 4코어가 있고, 8쓰레드를 할당받아 일을 할 수 있다는 말입니다.
>
> 그렇다면 다시, 안드로이드에서 하나의 프로세스와 하나의 UI 쓰레드만 있다고 가정해보겠습니다. 이 상황에서 OS는 해당 프로세스를 1개의 코어에 할당하여 1개의 쓰레드가 동작하게됩니다.
>
> 그럼 멀티 쓰레드의 경우는 어떻게 동작할까요? OS가 여유가 있다고 판단하게되면 CPU내의 최대 코어 갯수 만큼의 코어들을 해당 프로세스에 할당하여 쓰레드들이 병렬적으로 동작하게 되는 것 입니다.
> 예를들어 최대 코어 갯수가 4코어 8쓰레드라고 했을 때, 프로세스 내의 쓰레드가 8개면 최대 4코어를 할당받을 수 있고, 3개면 2코어를 할당받을 수 있습니다.
>
>  
>
> #### 동기 vs 비동기
>
> 동기는 **Synchronous**, 비동기는 **Asynchronous**라고 합니다. 그럼 이 둘은 어떤 차이가 있을까요?
>
> #### 동기 방식[Permalink](https://hwanine.github.io/android/MultThread/#동기-방식)
>
> **동기 방식**은 일반적으로 코드가 실행되는 방식입니다. 즉, 요청과 결과가 함께 발생합니다. 요청이 들어오고 결과가 발생할 때 까지 아무 작업을 할 수 없다는 것이죠.
>
> 우체국으로 예를 들어 직원을 쓰레드, 손님을 유저라고 가정합시다. 손님 10명이 줄을 서며 자기 차례를 기다리고 있습니다. 직원은 맨 처음 1명의 요청을 받아주고 있습니다. 이 때, 손님이 요청한 결과를 얻기 전 까지는, 다른 손님들은 계속 대기해야 합니다.
> 이것이 동기 방식입니다.
>
> 
>
> #### 비동기 방식[Permalink](https://hwanine.github.io/android/MultThread/#비동기-방식)
>
> **비동기 방식**은 요청과 결과가 별개로 발생합니다. 요청이 들어와도 결과를 기다리지 않고 계속 요청을 받습니다. 그리고 결과는 순서가 정해져 있지 않고 먼저 작업이 끝난 순으로 발생합니다. 즉, 결과를 간접적으로 전달합니다.
>
> 우체국에서 손님 10명이 줄을 서 있지만, 손님 1명의 요청을 듣고 손님을 돌려보냅니다. 그리고 계속 손님을 바로바로 받게 되죠. 결과가 나오게되면 손님이 와서 바로 결과를 받을 수 있습니다.
> 이것이 비동기 방식입니다.
>
> 우리가 흔히 자바에서 사용하는 **AsyncTask**는 비동기 싱글 쓰레드 방식 입니다. 여기서 **ThreadpoolExecutor**를 통해 확장하게 되면, 다중 쓰레드 방식이 됩니다.
>
>  ![82157528-f6cb1780-98bc-11ea-87c3-2d5035909fbb](img/82157528-f6cb1780-98bc-11ea-87c3-2d5035909fbb.png)
>
> 이러한 비동기 프로그래밍을 왜 하는걸까요? 바로 **속도**입니다.
> 동기 프로그래밍은 요청이 끝나고 결과가 발생할 때 까지, 무작정 대기해야 하지만 비동기 프로그래밍은 기능 요청을 한 후, 다른 작업을 하고 있다가 이벤트가 발생하면 그 때 처리하면 되기 때문입니다. 특히 DB 호출이 잦은 경우 속도면에서 엄청난 이득이 있습니다.
>
> 
>
> 그러면 비동기 방식과 멀티 쓰레드는 어떤 차이가 있는거죠?
>
> #### 비동기 vs 멀티 쓰레드
>
> **멀티 쓰레드**는 대부분 비동기 방식과 같이 구현되기 때문에 차이를 잘 논하지는 않습니다. 또한 이에 관련해서 논쟁도 많구요. 실제로 큰 차이가 없습니다.하지만 멀티 쓰레드가 동기식으로 구현되었다면 작은 차이가 있습니다.
>
> 동기식 멀티 쓰레드는 비동기식 싱글/멀티 쓰레드와 차이가 있습니다. 예를들어 A쓰레드가 요청을하면 B쓰레드가 요청을 받습니다. 이후 B쓰레드가 작업을 하여 그 결과를 반환해야 A쓰레드가 동작하게 됩니다.
>
> 
>
> #### 결론[Permalink](https://hwanine.github.io/android/MultThread/#결론)
>
> 지금까지 프로세스와 쓰레드를 중점으로 알아보았습니다.
>
> **비동기 다중 쓰레드 방식**이 마냥 좋은 것 같지만 그렇지만은 않습니다. 쓰레드를 많이 사용하게되면 동기화 문제 같은 쓰레드 제어에 대한 노력이 많이 들어가게 되며 버그도 많이 발생할 수 있을 뿐더러, 프로그래밍 난이도가 가파르게 상승하게 됩니다. 물론 비동기 다중 쓰레드 방식을 사용하면 그런 노력을 하고도 남을 만큼, 프로그램이 엄청난 속도 향상을 한다는 것을 알 수 있을 겁니다.

## 클래스, 객체, 인스턴스

> 클래스 : 객체를 만들어 내기 위한 설계도 / 변수와 메소드의 집합
>
> 객체 : 소프트웨어 게셰에 구현할 대상
>
> 인스턴스 : 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체

## WEB

> HTML, CSS, js, jpg 등 정젇인 데이터를 처리하는 웹서버
>
> 클라이언트가 요청한 정적인 콘텥츠를 HTTP 프로토콜을 통하여 제공해주는 서버
>
> 동적인 요청이 클리언트로부터 들어왔을 때, 해당 요청을 웹 서버에서 처리할 수 없기 때문에 컨테인너로 보내주는 열할



## WAS

> JSP, ASP, PHP 등 사용자의 입력을 받아 서버에서 무언가를 처리하고 그 결과를 보여주는 동적인 데이터를 처리흐는 웹서버
>
> 웹 서버와 컨테이너를 붙여놓은 서버



## 동기, 비동기 방식

> **동기방식(Synchronous)**
>
> 요청을 보낸 후 응답(결과)를 받아야지만 다음 동작이 이루어지는 방식.
>
> 어떠한 일을 처리할 동안 다른 프로그램은 정지상태
>
> 실제 cpu가 느려지는 것은 아니나, 시스템의 전체적인 효율이 저하
>
> **비동기방식(Asynchronous)**
>
> 요청을 보낸 후 응답(결과)와는 상관없이 다음 방식이 동작하는 방식
>
> 결과가 주어지는데 시간이 걸리더라고 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용

## Servlet

> 클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그램



# 세션과 쿠키

> **세션**
>
> Server에만 저장
>
> **쿠키**
>
> String 만 저장
>
> Clint PC에 저장되어 조작이 가능함



## 보안 알고리즘

> **SHA**
>
>  SHA(Secure Hash Algorithm, 안전한 해시 알고리즘) 함수들은 서로 관련된 암호학적 해시 함수들의 모음
>
> SHA-256은 현재가장 많은 분야에서 채택하여 사용되고 있는 암호 방식
> 출력 속도가 빠르다는 장점



## 아파치

> 웹서버 = 80번 포트로 클라이언트 요청(POST,GET,DELETE)이 왔을때만 응답함.
> 정적인 데이터만 처리한다.(HTML,CSS,이미지 등).



## 톰캣

> WAS(Web Application Server)
> 컨테이너, 웹 컨테이너, 서블릿 컨테이너라고 부름
> JSP,서블릿처리,HTTP요청 수신 및 응답
> 톰캣이 아파치의 기능 일부를 가져와서 제공해주는 형태이기 때문에 같이 합쳐서 부른다. WAS(Web Application Server)



## ORM

> **객체관계매핑**
> ORM(Object-relatinal mapping)이란 객체(클래스)와 관계(관계형 데이터 베이스)와의 설정을 의미 합니다. 객체 지향 프로그래밍은 클래스를 사용하고 관계형 데이터 베이스는 테이블을 사용합니다. 여기서 객체 모델과 관계형 모델간에 불일치가 존재 하는데 이 객체간의 관계를 바탕으로 SQL을 자동 생성하여 불일치를 해결 하는 것이 ORM입니다.



## 스키마

> 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합



## 트랜잭션 4가지 특성 (ACID)

> 원자성 (Atomicity)
> 일관성 (Consistency)
> 독립성 (Isolation)
> 영속성 (Durability)



## 객체지향 5원칙 (SOLID)

>단일 책임 원칙(Single responsibility principle) : SRP
>개방 폐쇄 원칙(Open/closed principle) : OCP
>리스코프 치환 원칙(Liskov substitution principle) : LSP
>인터페이스 분리 원칙(Interface segregation principle) : ISP
>의존관계 역전 원칙(Dependency inversion principle) : DIP



## 동기 (Synchronous)와 비동기(Asynchronous)

- 동기 방식은 서버에서 요청을 보냈을 때 응답이 돌아와야 다음 동작을 수행할 수 있다. 즉 A작업이 모두 진행 될때까지 B작업은 대기해야한다.
- 비동기 방식은 반대로 요청을 보냈을 때 응답 상태와 상관없이 다음 동작을 수행 할 수 있다. 즉 A작업이 시작하면 동시에 B작업이 실행된다. A작업은 결과값이 나오는대로 출력된다.

AOP의 핵심 기능은 `코드를 수정하지 않으면서 공통 기능의 구현을 추가하는 것`이라고 강조하고 있습니다. 핵심 기능에 공통 기능을 추가하는 방법에는 아래와 같이 3가지 방법이 존재합니다.

- 컴파일 : 자바 파일을 클래스 파일로 만들 때 바이트코드를 조작하여 적용된 바이트코드를 생성
- 로드 타임 : 컴파일은 원래 클래스 그대로 하고, 클래스를 로딩하는 시점에 끼워서 넣는다.
- 런타임**(스프링 AOP)** : A라는 클래스를 빈으로 만들 때 A라는 타입의 프록시 빈을 감싸서 만든 후에, 프록시 빈이 클래스 중간에 코드를 추가해서 넣는다.
